# ============================================================================
# DESTROY OPERATIONS
# ============================================================================

.PHONY: destroy-dev destroy-stage destroy-prod destroy-all \
        empty-buckets-dev empty-buckets-stage empty-buckets-prod \
        empty-buckets-all empty-state-bucket verify-destroy

# ============================================================================
# DESTROY ENVIRONMENTS
# ============================================================================

destroy-dev:
	@echo "Destroying dev environment..."
	@echo "This will DELETE all resources in dev environment"
	@echo "Current AWS Account: $$(aws sts get-caller-identity --query Account --output text 2>/dev/null || echo 'Unknown')"
	@if [ "$(AUTO_APPROVE)" != "true" ]; then \
		read -p "Type 'destroy-dev' to confirm: " confirm; \
		if [ "$$confirm" != "destroy-dev" ]; then \
			echo "Destroy cancelled"; \
			exit 1; \
		fi; \
	fi
	@cd envs/dev && terraform destroy $$([ "$(AUTO_APPROVE)" = "true" ] && echo "-auto-approve" || echo "")
	@echo "Dev environment destroyed"

destroy-stage:
	@echo "Destroying stage environment..."
	@echo "This will DELETE all resources in stage environment"
	@echo "Current AWS Account: $$(aws sts get-caller-identity --query Account --output text 2>/dev/null || echo 'Unknown')"
	@if [ "$(AUTO_APPROVE)" != "true" ]; then \
		read -p "Type 'destroy-stage' to confirm: " confirm; \
		if [ "$$confirm" != "destroy-stage" ]; then \
			echo "Destroy cancelled"; \
			exit 1; \
		fi; \
	fi
	@cd envs/stage && terraform destroy $$([ "$(AUTO_APPROVE)" = "true" ] && echo "-auto-approve" || echo "")
	@echo "Stage environment destroyed"

destroy-prod:
	@echo "Destroying prod environment..."
	@echo "WARNING: PRODUCTION DESTROY"
	@echo "Current AWS Account: $$(aws sts get-caller-identity --query Account --output text 2>/dev/null || echo 'Unknown')"
	@if [ "$(AUTO_APPROVE)" != "true" ]; then \
		read -p "Type 'destroy-prod' to confirm: " confirm; \
		if [ "$$confirm" != "destroy-prod" ]; then \
			echo "Destroy cancelled"; \
			exit 1; \
		fi; \
	fi
	@cd envs/prod && terraform destroy $$([ "$(AUTO_APPROVE)" = "true" ] && echo "-auto-approve" || echo "")
	@echo "Production environment destroyed"

destroy-all:
	@echo "Complete Infrastructure Teardown"
	@echo "DANGER: This will destroy EVERYTHING"
	@echo "This includes:"
	@echo "  - All environments (prod, stage, dev)"
	@echo "  - GitHub OIDC configuration"
	@echo "  - Remote state infrastructure"
	@echo "  - All data in S3 buckets"
	@echo ""
	@if [ -f .envrc ]; then \
		export $$(cat .envrc | grep -v '^#' | xargs); \
		echo "AWS Profile: $$AWS_PROFILE"; \
	fi; \
	echo "Current AWS Account: $$(aws sts get-caller-identity --query Account --output text 2>/dev/null || echo 'Unknown')"; \
	echo ""; \
	read -p "Type 'destroy-everything' to confirm: " confirm; \
	if [ "$$confirm" = "destroy-everything" ]; then \
		$(MAKE) destroy-prod AUTO_APPROVE=true || true; \
		$(MAKE) destroy-stage AUTO_APPROVE=true || true; \
		$(MAKE) destroy-dev AUTO_APPROVE=true || true; \
		echo "Destroying OIDC..."; \
		cd global/iam_gh_oidc && terraform destroy -auto-approve || true; \
		cd ../..; \
		echo "Emptying state bucket before destroy..."; \
		$(MAKE) empty-state-bucket || true; \
		echo "Destroying remote state..."; \
		cd global/remote-state && terraform destroy -auto-approve || true; \
		echo "Complete teardown finished"; \
	else \
		echo "Teardown cancelled"; \
		exit 1; \
	fi

# ============================================================================
# EMPTY BUCKETS
# ============================================================================

empty-state-bucket:
	@echo "Emptying Terraform state bucket..."
	@if [ -f .envrc ]; then \
		export $$(cat .envrc | grep -v '^#' | xargs); \
	fi; \
	STATE_BUCKET=$$(cd global/remote-state && terraform output -raw s3_bucket_name 2>/dev/null); \
	if [ -z "$$STATE_BUCKET" ] || [ "$$STATE_BUCKET" = "null" ]; then \
		echo "  Trying to find bucket by naming convention..."; \
		ACCOUNT_ID=$$(aws sts get-caller-identity --query Account --output text 2>/dev/null); \
		REGION=$${AWS_REGION:-eu-west-3}; \
		STATE_BUCKET="tf-state-$${ACCOUNT_ID}-$${REGION}"; \
		echo "  Checking if bucket exists: $$STATE_BUCKET"; \
		aws s3api head-bucket --bucket $$STATE_BUCKET 2>/dev/null || { echo "  State bucket not found"; exit 0; }; \
	fi; \
	echo "  Found state bucket: $$STATE_BUCKET"; \
	echo "  Getting all object versions..."; \
	VERSIONS=$$(aws s3api list-object-versions --bucket $$STATE_BUCKET \
		--output json --query 'Versions[].{Key:Key,VersionId:VersionId}' 2>/dev/null); \
	if [ "$$VERSIONS" != "null" ] && [ "$$VERSIONS" != "[]" ] && [ -n "$$VERSIONS" ]; then \
		echo "  Deleting all versions..."; \
		aws s3api delete-objects --bucket $$STATE_BUCKET \
			--delete "{\"Objects\":$$VERSIONS,\"Quiet\":true}" 2>/dev/null || true; \
		echo "  Versions deleted"; \
	else \
		echo "  No versions found"; \
	fi; \
	echo "  Checking for delete markers..."; \
	MARKERS=$$(aws s3api list-object-versions --bucket $$STATE_BUCKET \
		--output json --query 'DeleteMarkers[].{Key:Key,VersionId:VersionId}' 2>/dev/null); \
	if [ "$$MARKERS" != "null" ] && [ "$$MARKERS" != "[]" ] && [ -n "$$MARKERS" ]; then \
		echo "  Deleting all delete markers..."; \
		aws s3api delete-objects --bucket $$STATE_BUCKET \
			--delete "{\"Objects\":$$MARKERS,\"Quiet\":true}" 2>/dev/null || true; \
		echo "  Delete markers removed"; \
	else \
		echo "  No delete markers found"; \
	fi; \
	echo "  State bucket is now empty"

empty-buckets-dev:
	@echo "Emptying all S3 buckets in dev environment..."
	@echo "This will delete all data in dev buckets"
	@read -p "Continue? [y/N] " -n 1 -r; \
	echo; \
	if [[ $$REPLY =~ ^[Yy]$$ ]]; then \
		cd envs/dev || exit 1; \
		BUCKETS=$$(terraform output -json data_lake_buckets 2>/dev/null | jq -r '.[]' 2>/dev/null); \
		LOG_BUCKET=$$(terraform output -raw log_bucket_name 2>/dev/null); \
		if [ -z "$$BUCKETS" ] && [ -z "$$LOG_BUCKET" ]; then \
			echo "  No buckets found or terraform not initialized"; \
			exit 1; \
		fi; \
		for bucket in $$BUCKETS $$LOG_BUCKET; do \
			if [ -n "$$bucket" ]; then \
				echo "  Emptying $$bucket..."; \
				aws s3 rm s3://$$bucket --recursive --quiet 2>/dev/null || true; \
				aws s3api delete-objects --bucket $$bucket \
					--delete "$$(aws s3api list-object-versions --bucket $$bucket \
					--query '{Objects: Versions[].{Key:Key,VersionId:VersionId}}' \
					--max-items 1000 2>/dev/null)" 2>/dev/null || true; \
			fi; \
		done; \
		echo "Buckets emptied"; \
	fi

empty-buckets-stage:
	@echo "Emptying all S3 buckets in stage environment..."
	@echo "This will delete all data in stage buckets"
	@read -p "Continue? [y/N] " -n 1 -r; \
	echo; \
	if [[ $$REPLY =~ ^[Yy]$$ ]]; then \
		cd envs/stage || exit 1; \
		BUCKETS=$$(terraform output -json data_lake_buckets 2>/dev/null | jq -r '.[]' 2>/dev/null); \
		LOG_BUCKET=$$(terraform output -raw log_bucket_name 2>/dev/null); \
		if [ -z "$$BUCKETS" ] && [ -z "$$LOG_BUCKET" ]; then \
			echo "  No buckets found or terraform not initialized"; \
			exit 1; \
		fi; \
		for bucket in $$BUCKETS $$LOG_BUCKET; do \
			if [ -n "$$bucket" ]; then \
				echo "  Emptying $$bucket..."; \
				aws s3 rm s3://$$bucket --recursive --quiet 2>/dev/null || true; \
				aws s3api delete-objects --bucket $$bucket \
					--delete "$$(aws s3api list-object-versions --bucket $$bucket \
					--query '{Objects: Versions[].{Key:Key,VersionId:VersionId}}' \
					--max-items 1000 2>/dev/null)" 2>/dev/null || true; \
			fi; \
		done; \
		echo "Buckets emptied"; \
	fi

empty-buckets-prod:
	@echo "Emptying all S3 buckets in prod environment..."
	@echo "This will delete all data in prod buckets"
	@read -p "Continue? [y/N] " -n 1 -r; \
	echo; \
	if [[ $$REPLY =~ ^[Yy]$$ ]]; then \
		cd envs/prod || exit 1; \
		BUCKETS=$$(terraform output -json data_lake_buckets 2>/dev/null | jq -r '.[]' 2>/dev/null); \
		LOG_BUCKET=$$(terraform output -raw log_bucket_name 2>/dev/null); \
		if [ -z "$$BUCKETS" ] && [ -z "$$LOG_BUCKET" ]; then \
			echo "  No buckets found or terraform not initialized"; \
			exit 1; \
		fi; \
		for bucket in $$BUCKETS $$LOG_BUCKET; do \
			if [ -n "$$bucket" ]; then \
				echo "  Emptying $$bucket..."; \
				aws s3 rm s3://$$bucket --recursive --quiet 2>/dev/null || true; \
				aws s3api delete-objects --bucket $$bucket \
					--delete "$$(aws s3api list-object-versions --bucket $$bucket \
					--query '{Objects: Versions[].{Key:Key,VersionId:VersionId}}' \
					--max-items 1000 2>/dev/null)" 2>/dev/null || true; \
			fi; \
		done; \
		echo "Buckets emptied"; \
	fi

empty-buckets-all:
	@echo "Emptying all S3 buckets in all environments..."
	@echo "This will delete all data in all buckets"
	@read -p "Continue? [y/N] " -n 1 -r; \
	echo; \
	if [[ $$REPLY =~ ^[Yy]$$ ]]; then \
		for env in dev stage prod; do \
			echo "Processing $$env environment..."; \
			cd envs/$$env || continue; \
			BUCKETS=$$(terraform output -json data_lake_buckets 2>/dev/null | jq -r '.[]' 2>/dev/null); \
			LOG_BUCKET=$$(terraform output -raw log_bucket_name 2>/dev/null); \
			if [ -z "$$BUCKETS" ] && [ -z "$$LOG_BUCKET" ]; then \
				echo "  No buckets found or terraform not initialized for $$env"; \
				cd ../..; \
				continue; \
			fi; \
			for bucket in $$BUCKETS $$LOG_BUCKET; do \
				if [ -n "$$bucket" ]; then \
					echo "  Emptying $$bucket..."; \
					aws s3 rm s3://$$bucket --recursive --quiet 2>/dev/null || true; \
					aws s3api delete-objects --bucket $$bucket \
						--delete "$$(aws s3api list-object-versions --bucket $$bucket \
						--query '{Objects: Versions[].{Key:Key,VersionId:VersionId}}' \
						--max-items 1000 2>/dev/null)" 2>/dev/null || true; \
				fi; \
			done; \
			cd ../..; \
		done; \
		echo "All buckets emptied"; \
	fi

# ============================================================================
# VERIFICATION
# ============================================================================

verify-destroy:
	@echo "Verifying resource cleanup..."
	@echo ""
	@echo "Checking S3 buckets:"
	@aws s3 ls 2>/dev/null | grep -E "(dp-dev|dp-stage|dp-prod|tf-state)" || echo "No lakehouse buckets found"
	@echo ""
	@echo "Checking DynamoDB tables:"
	@aws dynamodb list-tables 2>/dev/null | grep "tf-locks" || echo "No state lock table found"
	@echo ""
	@echo "Checking KMS keys (pending deletion):"
	@aws kms list-keys --query 'Keys[*].KeyId' --output text 2>/dev/null | while read key; do \
		aws kms describe-key --key-id $$key --query 'KeyMetadata.[KeyId,KeyState,Description]' --output text 2>/dev/null | grep -i "terraform\|lakehouse" || true; \
	done
	@echo ""
	@echo "Checking tagged resources:"
	@aws resourcegroupstaggingapi get-resources \
		--tag-filters Key=Project,Values=terraform-aws-lakehouse \
		--query 'ResourceTagMappingList[*].[ResourceARN]' \
		--output text 2>/dev/null || echo "No tagged resources found"
